# 2. Rust 基础入门

## 2.1 变量绑定与解构

### 2.1.1 变量绑定与解构

#### 变量命名

对于 `type-level` 的构造 Rust 倾向于使用**驼峰命名法**（UpperCamelCase），而对于 `value-level` 的构造使用蛇形命名法（snake_case）。

#### 变量绑定

```Rust
let x = 5;
```

#### 变量的可变性

`Rust` 可以手动设定变量的**可变性**（是否可修改变量的值，`Erlang` 即不可变）。兼顾灵活性和安全性，还可以带来运行性能上的提升。

`Rust` 的变量在<u>默认</u>情况下是<u>不可变</u>的。`mut` 可以将变量变为可变。

```Rust
let mut x = 5;
```

#### 不可变变量和常量之间的差异

常量使用 `const` 关键字，常量在程序运行的整个过程中都有效，对于需要在多处代码共享一个不可变的值时非常有用。

> Q：并不是在中途可以变，而是在定义的时候可以自主选择，那跟常量的区别在哪呢。
>
> A：const 的值在编译时可以确定，不可变变量再怎么不可变，它都还是变量啊，既然是运行时才能确定的东西当然要和 const 分开，这是再自然不过的事。一个是编译时确定，一个是运行时确定，不一定是具体的值，可以看情况而定。

#### 使用下划线开头忽略未使用的变量

你希望告诉 Rust **不要警告未使用的变量**，为此可以用下划线作为变量名的开头`let _x = 27`。

```rust
#[allow(unused_variables)]
```

#### 变量解构

<u>*暂时还没有很理解。*</u>学完模式匹配章节后，再回头来看。

#### 变量屏蔽

同名的新变量可以屏蔽之前的变量。

## 2.2 基本类型

**静态**类型语言，<u>基本类型</u>和<u>复合类型</u>。

### 2.2.1 数值类型

有符号整数 (`i8`, `i16`, <u>`i32`（默认）</u>, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, <u>`f64`（默认）</u>)。

Rust 的数值上可以使用方法。

#### 整数类型

| 长度       | 有符号类型                        | 无符号类型    |
| ---------- | --------------------------------- | ------------- |
| 8 位       | `i8`                              | `u8`          |
| 16 位      | `i16`                             | `u16`         |
| 32 位      | `i32`                             | `u32`         |
| 64 位      | `i64`                             | `u64`         |
| 128 位     | `i128`                            | `u128`        |
| 视架构而定 | `isize`                           | `usize`       |
| 数字范围   | $-(2^{n - 1}) \to  2^{n - 1} - 1$ | $0 \to 2^n-1$ |

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

> X：下划线是为了增加数字的可读性。

整数溢出，debug模式报错，release模式补码循环溢出。

> X：`i8::MAX` 可以得到 `i8` 类型的最大值。

#### 浮点类型

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

#### 有理数和负数

有理数和复数并未包含在标准库中，好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。

#### NaN

`NaN` 不能用来比较，可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN`。

#### 数字运算、位运算

只有同类型，才能运算。（不会自动转换，**必须是显式的**）

![image-20220711154142423](https://raw.githubusercontent.com/Yuukina/XSJ-Img/main/img/image-20220711154142423.png)

#### 序列

Rust 提供了一个非常简洁的方式序列（Range），用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，**不包含** 5 ；`1..=5`，生成从 1 到 5 的连续数字，**包含** 5，它的用途很简单，常常用于循环中。序列只允许用于数字或**字符类型**，字符类型：`'a'..='z'`。浮点数好像不行，倒过来好像也不可行。

### 2.2.2 字符、布尔、单元类型

#### 字符类型

Rust 的字符不仅仅是 `ASCII`，**<u>所有的 `Unicode` 值</u>**都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型，存储为 **<u>4 个字节</u>**。

> X：Rust 的字符只能用 `''` 来表示， `""` 是留给字符串的。

#### 布尔类型

`true`和`false`，存储为 **<u>1 个字节</u>**。

#### 单元类型

即 `()` ，其唯一的值也是 `()`，存储为 **<u>0 个字节</u>**。

这种用法和 Go 语言的 ***struct{}*** 类似，可以作为一个值用来占位，但是完全**不占用**任何内存。

`main` 函数就返回这个单元类型 `()`，你不能说 `main` 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的。

### 2.2.3 语句与表达式

Rust 的函数体是由一系列语句组成，最后由一个**表达式来返回值**。

```rust
let y = {
    let x = 3;
    x + 1
};
```

这也可以，神神奇奇，**语句块**也是一个表达式，返回值不需要 `;`。

### 2.2.4 函数

```rust
fn plus_or_minus(x:i32) -> i32 {
    if x > 5 {
        return x - 5
    }

    x + 5
}
```

- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
- 可以用 `return` 提前返回表达式。

**发散函数**：当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )

## 2.3 所有权和借用

所有权系统。

### 2.3.1 所有权

- **垃圾回收机制(GC，Garbage Collection)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

---

**栈**中的所有数据都必须占用**已知且固定大小**的内存空间。

当向**堆**上放入数据时，需要请求一定大小的内存空间，操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为**在堆上分配内存**，有时简称为 “分配”(allocating)，接着，该指针会被推入**栈**中。

---

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。

#### 所有权原则

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

> X：变量 `s` 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。代码中的显式字符串不是运行时生成的。

#### 变量绑定背后的数据交互

**浅拷贝**：Rust 有一个叫做 `Copy` 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用。

如：整数类型、布尔类型、浮点数类型、字符类型、仅包含 `Copy` 类型的元组、不可变应用 `&T` 等。

**任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**。

**所有权移交**：如`String` 不是基本类型，而且是存储在堆上的，因此不能自动拷贝。只能移交所有权，那么之前的变量将丧失所有权，无法再引用其指向的数据。

当所有权转移时，可变性也可以随之改变。

当解构一个变量时，变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。

**深拷贝**：对于不能浅拷贝的类型，如果也想拷贝而不是移交所有权，可以使用克隆方法（`clone`）。

#### 函数传值与返回

一样会发生 `移动` 或者 `复制`，就跟 `let` 语句一样。

### 2.3.2 引用与借用

获取变量的**引用**，称之为**借用(borrowing)**。

引用和解引用的使用，感觉就是指针`&`、`*`。允许你使用值，但是不获取所有权。

#### 不可变引用

```Rust
fn main() {
    let mut s = String::from("hello, ");

    borrow_object(&s) //&mut s
}

fn borrow_object(s: &String) {} //s: &mut String
```

#### 可变引用

同一作用域，特定数据**只能有一个**可变引用。减少数据竞争。（不可变引用可以有多个）。（大括号可以手动限制变量的作用域）。

可变引用与不可变引用**不能同时**存在。

**NLL**，Non-Lexical Lifetimes，新编译器优化，引用作用域的结束位置从花括号变成最后一次使用的位置。

#### 悬垂引用

意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。这在Rust中编译器会放置出现该错误。
