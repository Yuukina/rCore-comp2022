# 2.3 所有权和借用

所有权系统。

## 2.3.1 所有权

- **垃圾回收机制(GC，Garbage Collection)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

---

**栈**中的所有数据都必须占用**已知且固定大小**的内存空间。

当向**堆**上放入数据时，需要请求一定大小的内存空间，操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为**在堆上分配内存**，有时简称为 “分配”(allocating)，接着，该指针会被推入**栈**中。

---

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。

### 所有权原则

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

> X：变量 `s` 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。代码中的显式字符串不是运行时生成的。

### 变量绑定背后的数据交互

**浅拷贝**：Rust 有一个叫做 `Copy` 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用。

如：整数类型、布尔类型、浮点数类型、字符类型、仅包含 `Copy` 类型的元组、不可变应用 `&T` 等。

**任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**。

**所有权移交**：如`String` 不是基本类型，而且是存储在堆上的，因此不能自动拷贝。只能移交所有权，那么之前的变量将丧失所有权，无法再引用其指向的数据。

当所有权转移时，可变性也可以随之改变。

当解构一个变量时，变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。

**深拷贝**：对于不能浅拷贝的类型，如果也想拷贝而不是移交所有权，可以使用克隆方法（`clone`）。

### 函数传值与返回

一样会发生 `移动` 或者 `复制`，就跟 `let` 语句一样。

## 2.3.2 引用与借用

获取变量的**引用**，称之为**借用(borrowing)**。

引用和解引用的使用 `&`、`*`，感觉就是指针。允许你使用值，但是不获取所有权。

### 不可变引用

```Rust
fn main() {
    let mut s = String::from("hello, ");

    borrow_object(&s) //&mut s
}

fn borrow_object(s: &String) {} //s: &mut String
```

### 可变引用

同一作用域，特定数据**只能有一个**可变引用。减少数据竞争。（不可变引用可以有多个）。（大括号可以手动限制变量的作用域）。

可变引用与不可变引用**不能同时**存在。

**NLL**，Non-Lexical Lifetimes，新编译器优化，引用作用域的结束位置从花括号变成最后一次使用的位置。

### 悬垂引用

意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。这在Rust中编译器会放置出现该错误。